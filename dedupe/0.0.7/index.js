(function(){"use strict";(function(e,r){globalThis.pluginStyle||(globalThis.pluginStyle={}),globalThis.pluginStyle[r.styleId]=e})('counter.svelte-mf9nd9{display:inline;background:var(--color-blue-dark);color:var(--color-white-dark);padding:0 .25rem;border-radius:2rem;line-height:18px;min-width:20px}group-card.svelte-kezdla.svelte-kezdla{display:inline-grid;border:var(--color-black) 1px solid;border-radius:var(--border-radius);cursor:pointer;height:80px;padding:0rem;grid-template-columns:1fr 25px}group-card.selected.svelte-kezdla.svelte-kezdla{background:var(--color-blue-dark);color:var(--color-yellow)}group-card.svelte-kezdla.svelte-kezdla:hover:not(.selected){background:var(--color-blue-light)}group-card.svelte-kezdla .left.svelte-kezdla{--padding:1rem;padding:var(--padding) 0 var(--padding) var(--padding);overflow:hidden}group-card.svelte-kezdla .right.svelte-kezdla{padding:.3rem}group-card.svelte-kezdla ul.svelte-kezdla{padding:0;margin:0}group-card.svelte-kezdla li.svelte-kezdla{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}group-card-list.svelte-1333sb2{display:flex;flex-direction:column;gap:1rem}button.tscd-button.svelte-1kqpdkt{--padding:.5rem;display:inline-flex;place-items:center;padding:var(--padding) calc(var(--padding) * 2);font-family:inherit;gap:.5rem;justify-content:center;letter-spacing:2%;line-height:100%;background-color:#000;color:#fff;border-radius:var(--border-radius);border:none;cursor:pointer;transition:all .1s ease-in-out}button.tscd-button.svelte-1kqpdkt:hover{background-color:var(--color-gray-1);color:#000}button.tscd-button.block.svelte-1kqpdkt{width:100%}button.tscd-button.primary.dangerous.svelte-1kqpdkt,button.tscd-button.secondary.dangerous.svelte-1kqpdkt,button.tscd-button.tertiary.dangerous.svelte-1kqpdkt{color:var(--color-pink)}button.tscd-button.primary.dangerous.svelte-1kqpdkt:hover,button.tscd-button.secondary.dangerous.svelte-1kqpdkt:hover,button.tscd-button.tertiary.dangerous.svelte-1kqpdkt:hover{background-color:var(--color-pink);color:var(--color-white)}button.tscd-button.primary.svelte-1kqpdkt:disabled,button.tscd-button.primary.svelte-1kqpdkt:disabled:hover,button.tscd-button.secondary.svelte-1kqpdkt:disabled,button.tscd-button.secondary.svelte-1kqpdkt:disabled:hover,button.tscd-button.tertiary.svelte-1kqpdkt:disabled,button.tscd-button.tertiary.svelte-1kqpdkt:disabled:hover{background-color:var(--color-grey-3);color:var(--color-grey-1)}button.tscd-button.primary.svelte-1kqpdkt{background-color:var(--color-blue-dark);color:var(--color-white);border:var(--color-blue-dark) thin solid}button.tscd-button.primary.svelte-1kqpdkt:hover{background-color:var(--color-blue);color:var(--color-yellow)}button.tscd-button.primary.svelte-1kqpdkt:active{background-color:var(--color-blue-light);color:var(--color-black)}button.tscd-button.secondary.svelte-1kqpdkt{background-color:var(--color-white);color:var(--color-blue);border:black thin solid}button.tscd-button.secondary.svelte-1kqpdkt:hover{background-color:var(--color-blue-light)}button.tscd-button.secondary.svelte-1kqpdkt:active{background-color:var(--color-blue-dark);color:var(--color-yellow)}button.tscd-button.tertiary.svelte-1kqpdkt{background:none;border:none;color:var(--color-blue)}button.tscd-button.tertiary.svelte-1kqpdkt:hover{background:var(--color-blue-light)}button.tscd-button.tertiary.svelte-1kqpdkt:active{background:var(--color-blue);color:var(--color-white)}button.tscd-button.tertiary.svelte-1kqpdkt:disabled,button.tscd-button.tertiary.svelte-1kqpdkt:disabled:hover{background:none}label.svelte-8pg148{display:flex;align-items:center;gap:.5rem}merger.svelte-ejwarz.svelte-ejwarz{display:grid;height:100%;grid-template-rows:2fr auto;grid-template-columns:repeat(2,auto) 1fr;text-align:left;gap:.5rem}merger.svelte-ejwarz ul.svelte-ejwarz{margin:0;padding:0 1rem;display:flex;flex-direction:column;gap:.5rem;list-style-type:none}merger.svelte-ejwarz .action.svelte-ejwarz{grid-column:3/4;justify-self:left;padding:2rem}merger.svelte-ejwarz .structure.svelte-ejwarz{border-right:var(--color-black) thin solid;display:grid;grid-template-rows:auto 1fr;height:100%;overflow:hidden;gap:4.5rem}merger.svelte-ejwarz .structure ul.svelte-ejwarz{height:100%;overflow:auto}merger.svelte-ejwarz .list-container.svelte-ejwarz{border-right:var(--color-black) thin solid;display:grid;height:100%;grid-template-rows:auto auto 1fr;gap:1rem}merger.svelte-ejwarz .list-container ul.svelte-ejwarz{height:100%;overflow:auto}merger.svelte-ejwarz .list.svelte-ejwarz{display:flex;flex-direction:column;gap:.5rem}merger.svelte-ejwarz>div.svelte-ejwarz{padding:.5rem}merger.svelte-ejwarz .select-all-container.svelte-ejwarz{margin-bottom:1rem;display:flex;justify-content:end}merger.svelte-ejwarz .action.svelte-ejwarz{display:flex;flex-direction:row;gap:.5rem;height:40px}merger.svelte-ejwarz .usage.svelte-ejwarz{height:100%;overflow:hidden;display:grid;grid-template-rows:auto 1fr;gap:4.5rem}merger.svelte-ejwarz .usage ul.svelte-ejwarz{height:100%;overflow:auto}:root,:host{--color-white:#FFFFFF;--color-white-dark:#f2f2f2;--color-yellow:#D9D800;--color-blue:#004552;--color-blue-dark:#14343e;--color-blue-1:#3253A8;--color-blue-light:#e5ecee;--color-torques:#007D80;--color-green:#288409;--color-black:#000000;--color-beige-1:burlywood;--color-beige-2:blanchedalmond;--color-pink:#C73C61;--color-grey-1:#626262;--color-grey-2:#808080;--color-grey-3:#bdbdbd;--color-primary:var(--color-yellow);--color-secondary:var(--color-blue);--color-text:var(--color-white);--color-text-disabled-1:rgba(0, 0, 0, .4);--border-radius:5px;--font-family:"Avenir Next", sans-serif;--letter-spacing:.2px;--font-size:12px;--color-ied-focus:var(--color-beige-1);--color-ied-focus-hover:var(--color-beige-2);--color-message-goose:var(--color-green);--color-message-mms:var(--color-blue-1);--color-message-sampledvalues:var(--color-pink);--sidebar-width:400px}:root,:host{font-family:var(--font-family);letter-spacing:var(--letter-spacing);font-size:var(--font-size)}.btn-group.svelte-58nl5q.svelte-58nl5q.svelte-58nl5q{--color-button-group-default:#5F6E75;--color-button-group-selected:#004552;display:flex;justify-content:center}.btn-group.svelte-58nl5q div.btn.svelte-58nl5q.svelte-58nl5q{border:none;background-color:var(--color-button-group-default);color:var(--color-white);padding:8px 12px;cursor:pointer;transition:background-color .2s ease-in-out}.btn-group.svelte-58nl5q div.btn.svelte-58nl5q.svelte-58nl5q:hover{background-color:var(--color-grey-2)}.btn-group.svelte-58nl5q label:last-of-type div.btn.svelte-58nl5q.svelte-58nl5q{border-top-right-radius:var(--border-radius);border-bottom-right-radius:var(--border-radius)}.btn-group.svelte-58nl5q label:first-of-type div.btn.svelte-58nl5q.svelte-58nl5q{border-top-left-radius:var(--border-radius);border-bottom-left-radius:var(--border-radius)}.btn-group.svelte-58nl5q input.svelte-58nl5q:checked~div.btn.svelte-58nl5q{background-color:var(--color-button-group-selected)}.btn-group.svelte-58nl5q input.svelte-58nl5q.svelte-58nl5q{display:none}.btn-group.disabled.svelte-58nl5q div.btn.svelte-58nl5q.svelte-58nl5q{background-color:var(--color-grey-3)!important;cursor:not-allowed}dedupe.svelte-ltuqys{--header-hight:146px;height:calc(100vh - var(--header-hight));display:block;padding:1rem;overflow:hidden}main.svelte-ltuqys{height:100%;overflow:hidden}layout.svelte-ltuqys{display:grid;grid-template-columns:330px 1fr;height:100%}sidebar.svelte-ltuqys{border-right:black thin solid;padding-right:1rem;height:100%;overflow:auto;display:flex;flex-direction:column;gap:1rem}',{styleId:"@oscd-plugins/dedupe"})})();
var st = Object.defineProperty;
var ct = (t, e, n) => e in t ? st(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Ee = (t, e, n) => (ct(t, typeof e != "symbol" ? e + "" : e, n), n);
function U() {
}
function xe(t) {
  return t();
}
function Ne() {
  return /* @__PURE__ */ Object.create(null);
}
function ae(t) {
  t.forEach(xe);
}
function et(t) {
  return typeof t == "function";
}
function V(t, e) {
  return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function";
}
function ot(t) {
  return Object.keys(t).length === 0;
}
function Ce(t) {
  return t ?? "";
}
function h(t, e) {
  t.appendChild(e);
}
function A(t, e, n) {
  t.insertBefore(e, n || null);
}
function w(t) {
  t.parentNode && t.parentNode.removeChild(t);
}
function ie(t, e) {
  for (let n = 0; n < t.length; n += 1)
    t[n] && t[n].d(e);
}
function g(t) {
  return document.createElement(t);
}
function j(t) {
  return document.createTextNode(t);
}
function L() {
  return j(" ");
}
function tt() {
  return j("");
}
function ce(t, e, n, r) {
  return t.addEventListener(e, n, r), () => t.removeEventListener(e, n, r);
}
function b(t, e, n) {
  n == null ? t.removeAttribute(e) : t.getAttribute(e) !== n && t.setAttribute(e, n);
}
function he(t, e, n) {
  e in t ? t[e] = typeof t[e] == "boolean" && n === "" ? !0 : n : b(t, e, n);
}
function it(t) {
  return Array.from(t.childNodes);
}
function K(t, e) {
  e = "" + e, t.wholeText !== e && (t.data = e);
}
function Ie(t, e) {
  for (let n = 0; n < t.options.length; n += 1) {
    const r = t.options[n];
    if (r.__value === e) {
      r.selected = !0;
      return;
    }
  }
  t.selectedIndex = -1;
}
function se(t, e, n) {
  t.classList[n ? "add" : "remove"](e);
}
function ut(t, e, { bubbles: n = !1, cancelable: r = !1 } = {}) {
  const l = document.createEvent("CustomEvent");
  return l.initCustomEvent(t, n, r, e), l;
}
let ye;
function be(t) {
  ye = t;
}
function at() {
  if (!ye)
    throw new Error("Function called outside component initialization");
  return ye;
}
function nt() {
  const t = at();
  return (e, n, { cancelable: r = !1 } = {}) => {
    const l = t.$$.callbacks[e];
    if (l) {
      const c = ut(e, n, { cancelable: r });
      return l.slice().forEach((s) => {
        s.call(t, c);
      }), !c.defaultPrevented;
    }
    return !0;
  };
}
function _e(t, e) {
  const n = t.$$.callbacks[e.type];
  n && n.slice().forEach((r) => r.call(this, e));
}
const me = [], De = [], ke = [], Le = [], ft = Promise.resolve();
let we = !1;
function dt() {
  we || (we = !0, ft.then(lt));
}
function Ae(t) {
  ke.push(t);
}
const Te = /* @__PURE__ */ new Set();
let de = 0;
function lt() {
  if (de !== 0)
    return;
  const t = ye;
  do {
    try {
      for (; de < me.length; ) {
        const e = me[de];
        de++, be(e), ht(e.$$);
      }
    } catch (e) {
      throw me.length = 0, de = 0, e;
    }
    for (be(null), me.length = 0, de = 0; De.length; )
      De.pop()();
    for (let e = 0; e < ke.length; e += 1) {
      const n = ke[e];
      Te.has(n) || (Te.add(n), n());
    }
    ke.length = 0;
  } while (me.length);
  for (; Le.length; )
    Le.pop()();
  we = !1, Te.clear(), be(t);
}
function ht(t) {
  if (t.fragment !== null) {
    t.update(), ae(t.before_update);
    const e = t.dirty;
    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(Ae);
  }
}
const ve = /* @__PURE__ */ new Set();
let ue;
function pe() {
  ue = {
    r: 0,
    c: [],
    p: ue
    // parent group
  };
}
function ge() {
  ue.r || ae(ue.c), ue = ue.p;
}
function S(t, e) {
  t && t.i && (ve.delete(t), t.i(e));
}
function C(t, e, n, r) {
  if (t && t.o) {
    if (ve.has(t))
      return;
    ve.add(t), ue.c.push(() => {
      ve.delete(t), r && (n && t.d(1), r());
    }), t.o(e);
  } else
    r && r();
}
function $(t) {
  t && t.c();
}
function W(t, e, n, r) {
  const { fragment: l, after_update: c } = t.$$;
  l && l.m(e, n), r || Ae(() => {
    const s = t.$$.on_mount.map(xe).filter(et);
    t.$$.on_destroy ? t.$$.on_destroy.push(...s) : ae(s), t.$$.on_mount = [];
  }), c.forEach(Ae);
}
function Y(t, e) {
  const n = t.$$;
  n.fragment !== null && (ae(n.on_destroy), n.fragment && n.fragment.d(e), n.on_destroy = n.fragment = null, n.ctx = []);
}
function mt(t, e) {
  t.$$.dirty[0] === -1 && (me.push(t), dt(), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
function x(t, e, n, r, l, c, s, o = [-1]) {
  const i = ye;
  be(t);
  const u = t.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: c,
    update: U,
    not_equal: l,
    bound: Ne(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (i ? i.$$.context : [])),
    // everything else
    callbacks: Ne(),
    dirty: o,
    skip_bound: !1,
    root: e.target || i.$$.root
  };
  s && s(u.root);
  let a = !1;
  if (u.ctx = n ? n(t, e.props || {}, (d, p, ...y) => {
    const k = y.length ? y[0] : p;
    return u.ctx && l(u.ctx[d], u.ctx[d] = k) && (!u.skip_bound && u.bound[d] && u.bound[d](k), a && mt(t, d)), p;
  }) : [], u.update(), a = !0, ae(u.before_update), u.fragment = r ? r(u.ctx) : !1, e.target) {
    if (e.hydrate) {
      const d = it(e.target);
      u.fragment && u.fragment.l(d), d.forEach(w);
    } else
      u.fragment && u.fragment.c();
    e.intro && S(t.$$.fragment), W(t, e.target, e.anchor, e.customElement), lt();
  }
  be(i);
}
class ee {
  $destroy() {
    Y(this, 1), this.$destroy = U;
  }
  $on(e, n) {
    if (!et(n))
      return U;
    const r = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return r.push(n), () => {
      const l = r.indexOf(n);
      l !== -1 && r.splice(l, 1);
    };
  }
  $set(e) {
    this.$$set && !ot(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
  }
}
const P = class {
  constructor(t) {
    this.root = t;
  }
  searchGSEs(t) {
    return this.searchElement(P.SelectorGSE, ["ldInst", "cbName"], t);
  }
  searchIEDs(t) {
    return this.searchElement(P.SelectorIED, ["name"], t);
  }
  searchGSEControls(t) {
    return this.searchElement(
      P.SelectorGSEControl,
      ["name", "datSet"],
      t
    );
  }
  searchInputs(t) {
    return this.searchElement(P.SelectorInput, [], t);
  }
  searchExtRef(t) {
    return this.searchElement(
      P.SelectorExtRef,
      [
        "iedName",
        "serviceType",
        // "ldInst",
        // "lnClass",
        // "lnInst",
        // "prefix",
        // "doName",
        // "daName",
        // "srcLDInst",
        // "srcPrefix",
        "srcCBName"
      ],
      t
    );
  }
  searchDataSetByName(t, e) {
    const n = `${P.SelectorDataSet}[name="${t}"]`, r = this.searchElement(
      n,
      ["name"],
      e
    );
    if (r.length !== 1) {
      console.log({ level: "error", msg: "we found not exactly one element", length: r.length });
      return;
    }
    return r[0];
  }
  searchElementsLDParent(t) {
    const e = t.closest(P.SelectorLD);
    if (!e) {
      console.log({ level: "error", msg: "could not find LD parent", element: t });
      return;
    }
    return Se(e, ["inst"]);
  }
  searchGSE(t, e, n) {
    const r = `${P.SelectorGSEElement}[ldInst='${t}'][cbName='${e}']`, l = this.searchElement(r, ["cbName", "ldInst"], n);
    if (l.length !== 1) {
      console.error({
        level: "error",
        msg: "we did not found exaclty one GSE element",
        length: l.length,
        ldInst: t,
        cbName: e,
        selector: r,
        root: this.root,
        options: n
      });
      return;
    }
    return l[0];
  }
  searchElementsParentSubnetwork(t) {
    const e = t.closest(P.SelectorSubNetwork);
    if (!e) {
      console.error({ level: "error", msg: "could not find SubNetwork parent", element: t });
      return;
    }
    return Se(e, ["name"]);
  }
  searchDOTypes(t) {
    return this.searchElement(P.SelectorDOType, ["id"], t);
  }
  searchDATypes(t) {
    return this.searchElement(P.SelectorDAType, ["id"], t);
  }
  searchEnumTypes(t) {
    return this.searchElement(P.SelectorEnumType, ["id"], t);
  }
  searchDOsByType(t, e) {
    const n = `${P.SelectorDO}[type='${t}']`;
    return this.searchElement(n, ["name", "type"], e);
  }
  searchLNodeTypes(t) {
    return this.searchElement(P.SelectorLNodeType, ["id", "lnClass"], t);
  }
  searchElementsByTypeAttr(t, e) {
    const n = `[type='${t}']`;
    return this.searchElement(n, [], e);
  }
  searchElementsByTypeAttr(t, e) {
    const n = `[type='${t}']`;
    return this.searchElement(n, [], e);
  }
  // 
  // Privates
  // 
  searchElement(t, e, n) {
    const r = this.determineRoot(n);
    return Array.from(r.querySelectorAll(t)).map((s) => Se(s, e));
  }
  determineRoot(t) {
    return t != null && t.root ? t.root : this.root;
  }
};
let N = P;
N.SelectorGSE = "GSE";
N.SelectorIED = "IED";
N.SelectorGSEControl = "GSEControl";
N.SelectorInput = "Inputs";
N.SelectorExtRef = "ExtRef";
N.SelectorDataSet = "DataSet";
N.SelectorLD = "LDevice";
N.SelectorGSEElement = "GSE";
N.SelectorSubNetwork = "SubNetwork";
N.SelectorDOType = "DOType";
N.SelectorDAType = "DAType";
N.SelectorEnumType = "EnumType";
N.SelectorDO = "DO";
N.SelectorLNodeType = "LNodeType";
function Se(t, e) {
  const n = { element: t };
  for (const r of e) {
    const l = r;
    n[l] = t.getAttribute(l) ?? "";
  }
  return n;
}
function _t(t) {
  let e, n;
  const r = {};
  for (const l of Array.from(t.children).filter((c) => c.tagName === "EnumVal").sort((c, s) => {
    let o, i;
    return parseInt((o = c.getAttribute("ord")) !== null && o !== void 0 ? o : "", 10) - parseInt((i = s.getAttribute("ord")) !== null && i !== void 0 ? i : "", 10);
  }))
    r[(e = l.getAttribute("ord")) !== null && e !== void 0 ? e : ""] = (n = l.textContent) !== null && n !== void 0 ? n : "";
  return { vals: r };
}
function pt(t) {
  let e;
  const n = {};
  for (const r of Array.from(t.children).filter((l) => l.tagName === "BDA").sort((l, c) => l.outerHTML.localeCompare(c.outerHTML))) {
    const [l, c, s, o, i] = [
      "bType",
      "type",
      "dchg",
      "dupd",
      "qchg"
    ].map((u) => r.getAttribute(u));
    n[(e = r.getAttribute("name")) !== null && e !== void 0 ? e : ""] = { bType: l, type: c, dchg: s, dupd: o, qchg: i };
  }
  return { bdas: n };
}
function gt(t) {
  const e = {};
  for (const r of Array.from(t.children).filter((l) => l.tagName === "SDO").sort((l, c) => l.outerHTML.localeCompare(c.outerHTML))) {
    const [l, c, s] = ["name", "type", "transient"].map((o) => r.getAttribute(o));
    e[l ?? ""] = { type: c, transient: s };
  }
  const n = {};
  for (const r of Array.from(t.children).filter((l) => l.tagName === "DA").sort((l, c) => l.outerHTML.localeCompare(c.outerHTML))) {
    const [l, c, s, o, i, u, a] = [
      "name",
      "fc",
      "bType",
      "type",
      "dchg",
      "dupd",
      "qchg"
    ].map((d) => r.getAttribute(d));
    n[l ?? ""] = {
      fc: c,
      bType: s,
      type: o,
      dchg: i,
      dupd: u,
      qchg: a
    };
  }
  return {
    sdos: e,
    das: n,
    cdc: t.getAttribute("cdc")
  };
}
function bt(t) {
  const e = {};
  for (const n of Array.from(t.children).filter((r) => r.tagName === "DO").sort((r, l) => r.outerHTML.localeCompare(l.outerHTML))) {
    const [r, l, c] = ["name", "type", "transient"].map((s) => n.getAttribute(s));
    e[r ?? ""] = { type: l, transient: c };
  }
  return {
    dos: e,
    lnClass: t.getAttribute("lnClass")
  };
}
const Oe = {
  EnumType: _t,
  DAType: pt,
  DOType: gt,
  LNodeType: bt
};
function yt(t) {
  let e, n;
  return (n = (e = Oe[t.tagName]) === null || e === void 0 ? void 0 : e.call(Oe, t)) !== null && n !== void 0 ? n : { xml: t.outerHTML };
}
function kt(t) {
  const e = yt(t);
  return vt(JSON.stringify(e));
}
async function vt(t) {
  const e = new TextEncoder().encode(t), n = await crypto.subtle.digest("SHA-256", e);
  return Array.from(new Uint8Array(n)).map((c) => c.toString(16).padStart(2, "0")).join("");
}
class Et {
  constructor(e) {
    this.scdQueries = e;
  }
  async findDuplicateObjectTypes() {
    return await this.findDuplicateTypes(this.scdQueries.searchDOTypes.bind(this.scdQueries));
  }
  async findDuplicateDataAttributeTypes() {
    return await this.findDuplicateTypes(this.scdQueries.searchDATypes.bind(this.scdQueries));
  }
  async findDuplicateLogicalNodeTypes() {
    return await this.findDuplicateTypes(this.scdQueries.searchLNodeTypes.bind(this.scdQueries));
  }
  async findDuplicateEnumTypes() {
    return await this.findDuplicateTypes(this.scdQueries.searchEnumTypes.bind(this.scdQueries));
  }
  async findDuplicateTypes(e) {
    const n = await e(), r = await Promise.all(
      n.map(this.createHashedElement.bind(this))
    ), l = this.groupByHash(r);
    return Object.values(l).filter((s) => s.length > 1);
  }
  findUserElements(e) {
    return this.scdQueries.searchElementsByTypeAttr(e);
  }
  async createHashedElement(e) {
    const n = await kt(e.element), r = this.findUserElements(e.id);
    return {
      element: e,
      hash: n,
      usages: r
    };
  }
  groupByHash(e) {
    const n = {};
    for (const r of e)
      n[r.hash] || (n[r.hash] = []), n[r.hash].push(r);
    return n;
  }
}
function Tt(t) {
  let e = (
    /*max*/
    t[1] - 1 + ""
  ), n, r;
  return {
    c() {
      n = j(e), r = j("+");
    },
    m(l, c) {
      A(l, n, c), A(l, r, c);
    },
    p(l, c) {
      c & /*max*/
      2 && e !== (e = /*max*/
      l[1] - 1 + "") && K(n, e);
    },
    d(l) {
      l && w(n), l && w(r);
    }
  };
}
function St(t) {
  let e;
  return {
    c() {
      e = j(
        /*count*/
        t[0]
      );
    },
    m(n, r) {
      A(n, e, r);
    },
    p(n, r) {
      r & /*count*/
      1 && K(
        e,
        /*count*/
        n[0]
      );
    },
    d(n) {
      n && w(e);
    }
  };
}
function Dt(t) {
  let e;
  function n(c, s) {
    return (
      /*count*/
      c[0] <= /*max*/
      c[1] ? St : Tt
    );
  }
  let r = n(t), l = r(t);
  return {
    c() {
      e = g("counter"), l.c(), b(e, "class", "svelte-mf9nd9");
    },
    m(c, s) {
      A(c, e, s), l.m(e, null);
    },
    p(c, [s]) {
      r === (r = n(c)) && l ? l.p(c, s) : (l.d(1), l = r(c), l && (l.c(), l.m(e, null)));
    },
    i: U,
    o: U,
    d(c) {
      c && w(e), l.d();
    }
  };
}
function wt(t, e, n) {
  let { count: r } = e, { max: l = 100 } = e;
  return t.$$set = (c) => {
    "count" in c && n(0, r = c.count), "max" in c && n(1, l = c.max);
  }, [r, l];
}
class At extends ee {
  constructor(e) {
    super(), x(this, e, wt, Dt, V, { count: 0, max: 1 });
  }
}
function Ge(t, e, n) {
  const r = t.slice();
  return r[7] = e[n], r;
}
function Me(t) {
  let e, n = (
    /*item*/
    t[7] + ""
  ), r;
  return {
    c() {
      e = g("li"), r = j(n), b(e, "class", "svelte-kezdla");
    },
    m(l, c) {
      A(l, e, c), h(e, r);
    },
    p(l, c) {
      c & /*displayedItems*/
      16 && n !== (n = /*item*/
      l[7] + "") && K(r, n);
    },
    d(l) {
      l && w(e);
    }
  };
}
function Nt(t) {
  let e, n, r, l, c, s, o, i, u, a = (
    /*displayedItems*/
    t[4]
  ), d = [];
  for (let p = 0; p < a.length; p += 1)
    d[p] = Me(Ge(t, a, p));
  return s = new At({
    props: { count: (
      /*items*/
      t[0].length
    ) }
  }), {
    c() {
      e = g("group-card"), n = g("div"), r = g("ul");
      for (let p = 0; p < d.length; p += 1)
        d[p].c();
      l = L(), c = g("div"), $(s.$$.fragment), b(r, "class", "svelte-kezdla"), b(n, "class", "left svelte-kezdla"), b(c, "class", "right svelte-kezdla"), he(
        e,
        "data-testid",
        /*dataTestid*/
        t[1]
      ), he(
        e,
        "title",
        /*titleText*/
        t[3]
      ), he(e, "class", "svelte-kezdla"), se(
        e,
        "selected",
        /*selected*/
        t[2]
      );
    },
    m(p, y) {
      A(p, e, y), h(e, n), h(n, r);
      for (let k = 0; k < d.length; k += 1)
        d[k].m(r, null);
      h(e, l), h(e, c), W(s, c, null), o = !0, i || (u = [
        ce(
          e,
          "click",
          /*click_handler*/
          t[5]
        ),
        ce(
          e,
          "keypress",
          /*keypress_handler*/
          t[6]
        )
      ], i = !0);
    },
    p(p, [y]) {
      if (y & /*displayedItems*/
      16) {
        a = /*displayedItems*/
        p[4];
        let _;
        for (_ = 0; _ < a.length; _ += 1) {
          const v = Ge(p, a, _);
          d[_] ? d[_].p(v, y) : (d[_] = Me(v), d[_].c(), d[_].m(r, null));
        }
        for (; _ < d.length; _ += 1)
          d[_].d(1);
        d.length = a.length;
      }
      const k = {};
      y & /*items*/
      1 && (k.count = /*items*/
      p[0].length), s.$set(k), (!o || y & /*dataTestid*/
      2) && he(
        e,
        "data-testid",
        /*dataTestid*/
        p[1]
      ), (!o || y & /*titleText*/
      8) && he(
        e,
        "title",
        /*titleText*/
        p[3]
      ), (!o || y & /*selected*/
      4) && se(
        e,
        "selected",
        /*selected*/
        p[2]
      );
    },
    i(p) {
      o || (S(s.$$.fragment, p), o = !0);
    },
    o(p) {
      C(s.$$.fragment, p), o = !1;
    },
    d(p) {
      p && w(e), ie(d, p), Y(s), i = !1, ae(u);
    }
  };
}
const Ct = 3;
function It(t, e, n) {
  let r, l, { items: c = [] } = e, { dataTestid: s = "" } = e, { selected: o = !1 } = e;
  function i(a) {
    _e.call(this, t, a);
  }
  function u(a) {
    _e.call(this, t, a);
  }
  return t.$$set = (a) => {
    "items" in a && n(0, c = a.items), "dataTestid" in a && n(1, s = a.dataTestid), "selected" in a && n(2, o = a.selected);
  }, t.$$.update = () => {
    t.$$.dirty & /*items*/
    1 && n(4, r = c.slice(0, Ct)), t.$$.dirty & /*items*/
    1 && n(3, l = c.join(`
`));
  }, [
    c,
    s,
    o,
    l,
    r,
    i,
    u
  ];
}
class Lt extends ee {
  constructor(e) {
    super(), x(this, e, It, Nt, V, { items: 0, dataTestid: 1, selected: 2 });
  }
}
function je(t, e, n) {
  const r = t.slice();
  return r[5] = e[n], r[7] = n, r;
}
function He(t) {
  let e, n;
  function r() {
    return (
      /*click_handler*/
      t[3](
        /*ii*/
        t[7]
      )
    );
  }
  return e = new Lt({
    props: {
      items: (
        /*itemSet*/
        t[5]
      ),
      dataTestid: `card_${/*ii*/
      t[7]}`,
      selected: (
        /*selectedIndex*/
        t[1] === /*ii*/
        t[7]
      )
    }
  }), e.$on("click", r), {
    c() {
      $(e.$$.fragment);
    },
    m(l, c) {
      W(e, l, c), n = !0;
    },
    p(l, c) {
      t = l;
      const s = {};
      c & /*itemSets*/
      1 && (s.items = /*itemSet*/
      t[5]), c & /*selectedIndex*/
      2 && (s.selected = /*selectedIndex*/
      t[1] === /*ii*/
      t[7]), e.$set(s);
    },
    i(l) {
      n || (S(e.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), n = !1;
    },
    d(l) {
      Y(e, l);
    }
  };
}
function Ot(t) {
  let e, n, r = (
    /*itemSets*/
    t[0]
  ), l = [];
  for (let s = 0; s < r.length; s += 1)
    l[s] = He(je(t, r, s));
  const c = (s) => C(l[s], 1, 1, () => {
    l[s] = null;
  });
  return {
    c() {
      e = g("group-card-list");
      for (let s = 0; s < l.length; s += 1)
        l[s].c();
      he(e, "class", "svelte-1333sb2");
    },
    m(s, o) {
      A(s, e, o);
      for (let i = 0; i < l.length; i += 1)
        l[i].m(e, null);
      n = !0;
    },
    p(s, [o]) {
      if (o & /*itemSets, selectedIndex, handleClick*/
      7) {
        r = /*itemSets*/
        s[0];
        let i;
        for (i = 0; i < r.length; i += 1) {
          const u = je(s, r, i);
          l[i] ? (l[i].p(u, o), S(l[i], 1)) : (l[i] = He(u), l[i].c(), S(l[i], 1), l[i].m(e, null));
        }
        for (pe(), i = r.length; i < l.length; i += 1)
          c(i);
        ge();
      }
    },
    i(s) {
      if (!n) {
        for (let o = 0; o < r.length; o += 1)
          S(l[o]);
        n = !0;
      }
    },
    o(s) {
      l = l.filter(Boolean);
      for (let o = 0; o < l.length; o += 1)
        C(l[o]);
      n = !1;
    },
    d(s) {
      s && w(e), ie(l, s);
    }
  };
}
function Gt(t, e, n) {
  let { itemSets: r = [] } = e, { selectedIndex: l = -1 } = e;
  const c = nt();
  function s(i) {
    c("select", { index: i });
  }
  const o = (i) => s(i);
  return t.$$set = (i) => {
    "itemSets" in i && n(0, r = i.itemSets), "selectedIndex" in i && n(1, l = i.selectedIndex);
  }, [r, l, s, o];
}
class Mt extends ee {
  constructor(e) {
    super(), x(this, e, Gt, Ot, V, { itemSets: 0, selectedIndex: 1 });
  }
}
function jt(t) {
  let e, n, r, l, c;
  return {
    c() {
      e = g("button"), n = j(
        /*label*/
        t[2]
      ), b(e, "class", r = Ce(`tscd-button ${/*type*/
      t[5]}`) + " svelte-1kqpdkt"), e.disabled = /*disabled*/
      t[4], b(
        e,
        "data-testid",
        /*testid*/
        t[3]
      ), se(
        e,
        "block",
        /*block*/
        t[0]
      ), se(
        e,
        "dangerous",
        /*dangerous*/
        t[1]
      );
    },
    m(s, o) {
      A(s, e, o), h(e, n), l || (c = ce(
        e,
        "click",
        /*click_handler*/
        t[6]
      ), l = !0);
    },
    p(s, [o]) {
      o & /*label*/
      4 && K(
        n,
        /*label*/
        s[2]
      ), o & /*type*/
      32 && r !== (r = Ce(`tscd-button ${/*type*/
      s[5]}`) + " svelte-1kqpdkt") && b(e, "class", r), o & /*disabled*/
      16 && (e.disabled = /*disabled*/
      s[4]), o & /*testid*/
      8 && b(
        e,
        "data-testid",
        /*testid*/
        s[3]
      ), o & /*type, block*/
      33 && se(
        e,
        "block",
        /*block*/
        s[0]
      ), o & /*type, dangerous*/
      34 && se(
        e,
        "dangerous",
        /*dangerous*/
        s[1]
      );
    },
    i: U,
    o: U,
    d(s) {
      s && w(e), l = !1, c();
    }
  };
}
function Ht(t, e, n) {
  let { block: r = !1 } = e, { dangerous: l = !1 } = e, { label: c } = e, { testid: s = "" } = e, { disabled: o = !1 } = e, { type: i = "primary" } = e;
  function u(a) {
    _e.call(this, t, a);
  }
  return t.$$set = (a) => {
    "block" in a && n(0, r = a.block), "dangerous" in a && n(1, l = a.dangerous), "label" in a && n(2, c = a.label), "testid" in a && n(3, s = a.testid), "disabled" in a && n(4, o = a.disabled), "type" in a && n(5, i = a.type);
  }, [r, l, c, s, o, i, u];
}
class ze extends ee {
  constructor(e) {
    super(), x(this, e, Ht, jt, V, {
      block: 0,
      dangerous: 1,
      label: 2,
      testid: 3,
      disabled: 4,
      type: 5
    });
  }
}
function zt(t) {
  let e, n, r, l, c, s, o, i;
  return {
    c() {
      e = g("checkbox"), n = g("label"), r = g("input"), l = L(), c = g("span"), s = j(
        /*label*/
        t[1]
      ), b(r, "type", "checkbox"), b(n, "class", "svelte-8pg148"), b(
        e,
        "data-testid",
        /*testid*/
        t[2]
      );
    },
    m(u, a) {
      A(u, e, a), h(e, n), h(n, r), r.checked = /*checked*/
      t[0], h(n, l), h(n, c), h(c, s), o || (i = [
        ce(
          r,
          "change",
          /*change_handler*/
          t[3]
        ),
        ce(
          r,
          "input",
          /*input_handler*/
          t[4]
        ),
        ce(
          r,
          "change",
          /*input_change_handler*/
          t[5]
        )
      ], o = !0);
    },
    p(u, [a]) {
      a & /*checked*/
      1 && (r.checked = /*checked*/
      u[0]), a & /*label*/
      2 && K(
        s,
        /*label*/
        u[1]
      ), a & /*testid*/
      4 && b(
        e,
        "data-testid",
        /*testid*/
        u[2]
      );
    },
    i: U,
    o: U,
    d(u) {
      u && w(e), o = !1, ae(i);
    }
  };
}
function Bt(t, e, n) {
  let { checked: r = !1 } = e, { label: l } = e, { testid: c = "" } = e;
  function s(u) {
    _e.call(this, t, u);
  }
  function o(u) {
    _e.call(this, t, u);
  }
  function i() {
    r = this.checked, n(0, r);
  }
  return t.$$set = (u) => {
    "checked" in u && n(0, r = u.checked), "label" in u && n(1, l = u.label), "testid" in u && n(2, c = u.testid);
  }, [r, l, c, s, o, i];
}
class qt extends ee {
  constructor(e) {
    super(), x(this, e, Bt, zt, V, { checked: 0, label: 1, testid: 2 });
  }
}
function Be(t, e, n) {
  const r = t.slice();
  return r[15] = e[n], r[17] = n, r;
}
function qe(t, e, n) {
  const r = t.slice();
  return r[18] = e[n], r;
}
function Qe(t, e, n) {
  const r = t.slice();
  return r[15] = e[n], r[17] = n, r;
}
function Pe(t, e, n) {
  const r = t.slice();
  return r[15] = e[n], r;
}
function Re(t) {
  let e, n = (
    /*item*/
    t[15] + ""
  ), r;
  return {
    c() {
      e = g("li"), r = j(n);
    },
    m(l, c) {
      A(l, e, c), h(e, r);
    },
    p(l, c) {
      c & /*structure*/
      2 && n !== (n = /*item*/
      l[15] + "") && K(r, n);
    },
    d(l) {
      l && w(e);
    }
  };
}
function Fe(t) {
  let e, n, r, l;
  function c(...s) {
    return (
      /*change_handler*/
      t[12](
        /*ii*/
        t[17],
        ...s
      )
    );
  }
  return n = new qt({
    props: {
      checked: (
        /*checkedIndexes*/
        t[2].has(
          /*ii*/
          t[17]
        )
      ),
      label: (
        /*item*/
        t[15].label
      ),
      testid: `merger_checkbox-${/*ii*/
      t[17]}`
    }
  }), n.$on("change", c), {
    c() {
      e = g("li"), $(n.$$.fragment), r = L();
    },
    m(s, o) {
      A(s, e, o), W(n, e, null), h(e, r), l = !0;
    },
    p(s, o) {
      t = s;
      const i = {};
      o & /*checkedIndexes*/
      4 && (i.checked = /*checkedIndexes*/
      t[2].has(
        /*ii*/
        t[17]
      )), o & /*items*/
      1 && (i.label = /*item*/
      t[15].label), n.$set(i);
    },
    i(s) {
      l || (S(n.$$.fragment, s), l = !0);
    },
    o(s) {
      C(n.$$.fragment, s), l = !1;
    },
    d(s) {
      s && w(e), Y(n);
    }
  };
}
function Ue(t) {
  let e, n, r = (
    /*element*/
    t[18].type + ""
  ), l, c, s = (
    /*element*/
    t[18].name + ""
  ), o, i, u = (
    /*element*/
    t[18].dot + ""
  ), a, d;
  return {
    c() {
      e = g("li"), n = j("["), l = j(r), c = j("] "), o = j(s), i = j(" ("), a = j(u), d = j(")");
    },
    m(p, y) {
      A(p, e, y), h(e, n), h(e, l), h(e, c), h(e, o), h(e, i), h(e, a), h(e, d);
    },
    p(p, y) {
      y & /*affectedElements*/
      16 && r !== (r = /*element*/
      p[18].type + "") && K(l, r), y & /*affectedElements*/
      16 && s !== (s = /*element*/
      p[18].name + "") && K(o, s), y & /*affectedElements*/
      16 && u !== (u = /*element*/
      p[18].dot + "") && K(a, u);
    },
    d(p) {
      p && w(e);
    }
  };
}
function Je(t) {
  let e, n = (
    /*item*/
    t[15].label + ""
  ), r;
  return {
    c() {
      e = g("option"), r = j(n), e.__value = /*ii*/
      t[17], e.value = e.__value;
    },
    m(l, c) {
      A(l, e, c), h(e, r);
    },
    p(l, c) {
      c & /*items*/
      1 && n !== (n = /*item*/
      l[15].label + "") && K(r, n);
    },
    d(l) {
      l && w(e);
    }
  };
}
function Qt(t) {
  let e, n, r, l, c, s, o, i, u, a, d, p, y, k, _, v, q, T, Q, H, B, J, E, O, G, le, te, ne = (
    /*structure*/
    t[1]
  ), z = [];
  for (let f = 0; f < ne.length; f += 1)
    z[f] = Re(Pe(t, ne, f));
  d = new ze({
    props: {
      label: "Select All",
      testid: "merger_select-all",
      type: "secondary"
    }
  }), d.$on(
    "click",
    /*handleSelectAll*/
    t[9]
  );
  let Z = (
    /*items*/
    t[0]
  ), D = [];
  for (let f = 0; f < Z.length; f += 1)
    D[f] = Fe(Qe(t, Z, f));
  const oe = (f) => C(D[f], 1, 1, () => {
    D[f] = null;
  });
  let re = (
    /*affectedElements*/
    t[4]
  ), R = [];
  for (let f = 0; f < re.length; f += 1)
    R[f] = Ue(qe(t, re, f));
  let fe = (
    /*items*/
    t[0]
  ), F = [];
  for (let f = 0; f < fe.length; f += 1)
    F[f] = Je(Be(t, fe, f));
  return O = new ze({
    props: {
      label: "Merge",
      block: !0,
      testid: "merger_button-merge",
      disabled: !/*isMergePossible*/
      t[5]
    }
  }), O.$on(
    "click",
    /*handleMergeClick*/
    t[7]
  ), {
    c() {
      e = g("merger"), n = g("div"), r = g("h3"), r.textContent = "Structure", l = L(), c = g("ul");
      for (let f = 0; f < z.length; f += 1)
        z[f].c();
      s = L(), o = g("div"), i = g("h3"), i.textContent = "Duplicate DOTypes", u = L(), a = g("div"), $(d.$$.fragment), p = L(), y = g("ul");
      for (let f = 0; f < D.length; f += 1)
        D[f].c();
      k = L(), _ = g("div"), v = g("h3"), v.textContent = "Affected Nodes", q = L(), T = g("ul");
      for (let f = 0; f < R.length; f += 1)
        R[f].c();
      Q = L(), H = g("div"), B = g("select"), J = g("option"), J.textContent = "Select a merge target";
      for (let f = 0; f < F.length; f += 1)
        F[f].c();
      E = L(), $(O.$$.fragment), b(c, "class", "structure-list svelte-ejwarz"), b(n, "class", "structure svelte-ejwarz"), b(a, "class", "select-all-container svelte-ejwarz"), b(y, "class", "list svelte-ejwarz"), b(o, "class", "list-container svelte-ejwarz"), b(T, "class", "svelte-ejwarz"), b(_, "class", "usage svelte-ejwarz"), J.__value = -1, J.value = J.__value, J.disabled = !0, J.selected = !0, b(B, "data-testid", "merger_merge-target"), b(H, "class", "action svelte-ejwarz"), b(e, "class", "svelte-ejwarz");
    },
    m(f, I) {
      A(f, e, I), h(e, n), h(n, r), h(n, l), h(n, c);
      for (let M = 0; M < z.length; M += 1)
        z[M].m(c, null);
      h(e, s), h(e, o), h(o, i), h(o, u), h(o, a), W(d, a, null), h(o, p), h(o, y);
      for (let M = 0; M < D.length; M += 1)
        D[M].m(y, null);
      h(e, k), h(e, _), h(_, v), h(_, q), h(_, T);
      for (let M = 0; M < R.length; M += 1)
        R[M].m(T, null);
      h(e, Q), h(e, H), h(H, B), h(B, J);
      for (let M = 0; M < F.length; M += 1)
        F[M].m(B, null);
      Ie(
        B,
        /*selectedMergeTargetIndex*/
        t[3]
      ), h(H, E), W(O, H, null), G = !0, le || (te = ce(
        B,
        "change",
        /*handleTargetInputChange*/
        t[8]
      ), le = !0);
    },
    p(f, [I]) {
      if (I & /*structure*/
      2) {
        ne = /*structure*/
        f[1];
        let m;
        for (m = 0; m < ne.length; m += 1) {
          const X = Pe(f, ne, m);
          z[m] ? z[m].p(X, I) : (z[m] = Re(X), z[m].c(), z[m].m(c, null));
        }
        for (; m < z.length; m += 1)
          z[m].d(1);
        z.length = ne.length;
      }
      if (I & /*checkedIndexes, items, handleSourceChange*/
      69) {
        Z = /*items*/
        f[0];
        let m;
        for (m = 0; m < Z.length; m += 1) {
          const X = Qe(f, Z, m);
          D[m] ? (D[m].p(X, I), S(D[m], 1)) : (D[m] = Fe(X), D[m].c(), S(D[m], 1), D[m].m(y, null));
        }
        for (pe(), m = Z.length; m < D.length; m += 1)
          oe(m);
        ge();
      }
      if (I & /*affectedElements*/
      16) {
        re = /*affectedElements*/
        f[4];
        let m;
        for (m = 0; m < re.length; m += 1) {
          const X = qe(f, re, m);
          R[m] ? R[m].p(X, I) : (R[m] = Ue(X), R[m].c(), R[m].m(T, null));
        }
        for (; m < R.length; m += 1)
          R[m].d(1);
        R.length = re.length;
      }
      if (I & /*items*/
      1) {
        fe = /*items*/
        f[0];
        let m;
        for (m = 0; m < fe.length; m += 1) {
          const X = Be(f, fe, m);
          F[m] ? F[m].p(X, I) : (F[m] = Je(X), F[m].c(), F[m].m(B, null));
        }
        for (; m < F.length; m += 1)
          F[m].d(1);
        F.length = fe.length;
      }
      (!G || I & /*selectedMergeTargetIndex*/
      8) && Ie(
        B,
        /*selectedMergeTargetIndex*/
        f[3]
      );
      const M = {};
      I & /*isMergePossible*/
      32 && (M.disabled = !/*isMergePossible*/
      f[5]), O.$set(M);
    },
    i(f) {
      if (!G) {
        S(d.$$.fragment, f);
        for (let I = 0; I < Z.length; I += 1)
          S(D[I]);
        S(O.$$.fragment, f), G = !0;
      }
    },
    o(f) {
      C(d.$$.fragment, f), D = D.filter(Boolean);
      for (let I = 0; I < D.length; I += 1)
        C(D[I]);
      C(O.$$.fragment, f), G = !1;
    },
    d(f) {
      f && w(e), ie(z, f), Y(d), ie(D, f), ie(R, f), ie(F, f), Y(O), le = !1, te();
    }
  };
}
function Pt(t, e, n) {
  let r, l, c, { items: s = [] } = e, { structure: o = [] } = e;
  const i = nt();
  let u = /* @__PURE__ */ new Set(), a = [];
  function d(T, Q) {
    Q.target.checked ? u.add(T) : u.delete(T), n(2, u);
  }
  function p(T) {
    const Q = [];
    for (const H of T) {
      const B = s[H], J = B.usages;
      for (const E of J)
        Q.push({
          name: E.name,
          type: E.type,
          dot: B.label
        });
    }
    return Q;
  }
  function y(T) {
    const Q = [...Array.from(u.values())];
    r && i("merge", {
      selectedIndexes: Q,
      selectedMergeTargetIndex: k
    });
  }
  let k = -1;
  function _(T) {
    const H = T.target.value, B = parseInt(H);
    n(3, k = B);
  }
  function v(T) {
    T.target.checked, s.forEach((Q, H) => u.add(H)), n(2, u);
  }
  const q = (T, Q) => d(T, Q);
  return t.$$set = (T) => {
    "items" in T && n(0, s = T.items), "structure" in T && n(1, o = T.structure);
  }, t.$$.update = () => {
    t.$$.dirty & /*checkedIndexes*/
    4 && n(4, a = p([...u.values()])), t.$$.dirty & /*checkedIndexes*/
    4 && n(10, c = u.size > 0), t.$$.dirty & /*selectedMergeTargetIndex*/
    8 && n(11, l = k > -1), t.$$.dirty & /*isSomeDuplicateSelected, isTargetSelected*/
    3072 && n(5, r = c && l);
  }, [
    s,
    o,
    u,
    k,
    a,
    r,
    d,
    y,
    _,
    v,
    c,
    l,
    q
  ];
}
class Rt extends ee {
  constructor(e) {
    super(), x(this, e, Pt, Qt, V, { items: 0, structure: 1 });
  }
}
const Ft = {
  name: "",
  type: ""
};
class Ut extends ee {
  constructor(e) {
    super(), x(this, e, null, null, V, {});
  }
}
function Ve(t, e, n) {
  const r = t.slice();
  return r[4] = e[n], r;
}
function Xe(t) {
  let e, n, r, l, c, s, o, i = (
    /*option*/
    t[4].label + ""
  ), u, a, d, p, y;
  return {
    c() {
      e = g("label"), n = g("input"), s = L(), o = g("div"), u = j(i), a = L(), b(n, "type", "radio"), b(n, "name", "option"), b(n, "id", r = /*option*/
      t[4].id), n.checked = l = /*option*/
      t[4].id === /*selectedID*/
      t[0], n.value = c = /*option*/
      t[4].id, n.disabled = /*disabled*/
      t[2], b(n, "class", "svelte-58nl5q"), b(o, "class", "btn svelte-58nl5q"), b(e, "for", d = /*option*/
      t[4].id);
    },
    m(k, _) {
      A(k, e, _), h(e, n), h(e, s), h(e, o), h(o, u), h(e, a), p || (y = ce(
        n,
        "change",
        /*change_handler*/
        t[3]
      ), p = !0);
    },
    p(k, _) {
      _ & /*options*/
      2 && r !== (r = /*option*/
      k[4].id) && b(n, "id", r), _ & /*options, selectedID*/
      3 && l !== (l = /*option*/
      k[4].id === /*selectedID*/
      k[0]) && (n.checked = l), _ & /*options*/
      2 && c !== (c = /*option*/
      k[4].id) && (n.value = c), _ & /*disabled*/
      4 && (n.disabled = /*disabled*/
      k[2]), _ & /*options*/
      2 && i !== (i = /*option*/
      k[4].label + "") && K(u, i), _ & /*options*/
      2 && d !== (d = /*option*/
      k[4].id) && b(e, "for", d);
    },
    d(k) {
      k && w(e), p = !1, y();
    }
  };
}
function Jt(t) {
  let e, n = (
    /*options*/
    t[1]
  ), r = [];
  for (let l = 0; l < n.length; l += 1)
    r[l] = Xe(Ve(t, n, l));
  return {
    c() {
      e = g("div");
      for (let l = 0; l < r.length; l += 1)
        r[l].c();
      b(e, "class", "btn-group svelte-58nl5q"), b(e, "data-testid", "button-group"), se(
        e,
        "disabled",
        /*disabled*/
        t[2]
      );
    },
    m(l, c) {
      A(l, e, c);
      for (let s = 0; s < r.length; s += 1)
        r[s].m(e, null);
    },
    p(l, [c]) {
      if (c & /*options, selectedID, disabled*/
      7) {
        n = /*options*/
        l[1];
        let s;
        for (s = 0; s < n.length; s += 1) {
          const o = Ve(l, n, s);
          r[s] ? r[s].p(o, c) : (r[s] = Xe(o), r[s].c(), r[s].m(e, null));
        }
        for (; s < r.length; s += 1)
          r[s].d(1);
        r.length = n.length;
      }
      c & /*disabled*/
      4 && se(
        e,
        "disabled",
        /*disabled*/
        l[2]
      );
    },
    i: U,
    o: U,
    d(l) {
      l && w(e), ie(r, l);
    }
  };
}
function Vt(t, e, n) {
  let { selectedID: r = "" } = e, { options: l = [] } = e, { disabled: c = !1 } = e;
  function s(o) {
    _e.call(this, t, o);
  }
  return t.$$set = (o) => {
    "selectedID" in o && n(0, r = o.selectedID), "options" in o && n(1, l = o.options), "disabled" in o && n(2, c = o.disabled);
  }, [r, l, c, s];
}
class Xt extends ee {
  constructor(e) {
    super(), x(this, e, Vt, Jt, V, { selectedID: 0, options: 1, disabled: 2 });
  }
}
function Ke(t) {
  let e = `${/*selectedGroupIndex*/
  t[0]}_${/*selectedType*/
  t[1]}`, n, r, l = We(t);
  return {
    c() {
      l.c(), n = tt();
    },
    m(c, s) {
      l.m(c, s), A(c, n, s), r = !0;
    },
    p(c, s) {
      s & /*selectedGroupIndex, selectedType*/
      3 && V(e, e = `${/*selectedGroupIndex*/
      c[0]}_${/*selectedType*/
      c[1]}`) ? (pe(), C(l, 1, 1, U), ge(), l = We(c), l.c(), S(l, 1), l.m(n.parentNode, n)) : l.p(c, s);
    },
    i(c) {
      r || (S(l), r = !0);
    },
    o(c) {
      C(l), r = !1;
    },
    d(c) {
      c && w(n), l.d(c);
    }
  };
}
function We(t) {
  let e, n;
  return e = new Rt({
    props: {
      items: (
        /*itemSets*/
        t[3][
          /*selectedGroupIndex*/
          t[0]
        ] ?? []
      ),
      structure: (
        /*structure*/
        t[4]
      )
    }
  }), e.$on(
    "merge",
    /*handleMerge*/
    t[8]
  ), {
    c() {
      $(e.$$.fragment);
    },
    m(r, l) {
      W(e, r, l), n = !0;
    },
    p(r, l) {
      const c = {};
      l & /*itemSets, selectedGroupIndex*/
      9 && (c.items = /*itemSets*/
      r[3][
        /*selectedGroupIndex*/
        r[0]
      ] ?? []), l & /*structure*/
      16 && (c.structure = /*structure*/
      r[4]), e.$set(c);
    },
    i(r) {
      n || (S(e.$$.fragment, r), n = !0);
    },
    o(r) {
      C(e.$$.fragment, r), n = !1;
    },
    d(r) {
      Y(e, r);
    }
  };
}
function Kt(t) {
  let e, n, r, l, c, s, o, i, u, a, d, p, y, k;
  e = new Ut({}), u = new Xt({
    props: {
      options: (
        /*typeOptions*/
        t[6]
      ),
      selectedID: (
        /*typeOptions*/
        t[6][0].id
      )
    }
  }), u.$on(
    "change",
    /*handleTypeChange*/
    t[7]
  ), d = new Mt({
    props: {
      itemSets: (
        /*itemSets*/
        t[3].map(Ye)
      ),
      selectedIndex: (
        /*selectedGroupIndex*/
        t[0]
      )
    }
  }), d.$on(
    "select",
    /*handleGroupSelect*/
    t[5]
  );
  let _ = (
    /*selectedGroupIndex*/
    t[0] > -1 && Ke(t)
  );
  return {
    c() {
      $(e.$$.fragment), n = L(), r = g("dedupe"), l = g("layout"), c = g("sidebar"), s = g("h3"), s.textContent = "Duplicates", o = L(), i = g("div"), $(u.$$.fragment), a = L(), $(d.$$.fragment), p = L(), y = g("main"), _ && _.c(), b(c, "class", "svelte-ltuqys"), b(y, "class", "svelte-ltuqys"), b(l, "class", "svelte-ltuqys"), b(r, "class", "svelte-ltuqys");
    },
    m(v, q) {
      W(e, v, q), A(v, n, q), A(v, r, q), h(r, l), h(l, c), h(c, s), h(c, o), h(c, i), W(u, i, null), h(c, a), W(d, c, null), h(l, p), h(l, y), _ && _.m(y, null), t[11](r), k = !0;
    },
    p(v, [q]) {
      const T = {};
      q & /*itemSets*/
      8 && (T.itemSets = /*itemSets*/
      v[3].map(Ye)), q & /*selectedGroupIndex*/
      1 && (T.selectedIndex = /*selectedGroupIndex*/
      v[0]), d.$set(T), /*selectedGroupIndex*/
      v[0] > -1 ? _ ? (_.p(v, q), q & /*selectedGroupIndex*/
      1 && S(_, 1)) : (_ = Ke(v), _.c(), S(_, 1), _.m(y, null)) : _ && (pe(), C(_, 1, 1, () => {
        _ = null;
      }), ge());
    },
    i(v) {
      k || (S(e.$$.fragment, v), S(u.$$.fragment, v), S(d.$$.fragment, v), S(_), k = !0);
    },
    o(v) {
      C(e.$$.fragment, v), C(u.$$.fragment, v), C(d.$$.fragment, v), C(_), k = !1;
    },
    d(v) {
      Y(e, v), v && w(n), v && w(r), Y(u), Y(d), _ && _.d(), t[11](null);
    }
  };
}
function Wt(t, e) {
  const r = t.element.cloneNode(!0);
  return r.setAttribute("type", e.id), Yt(t.element, r);
}
function Yt(t, e) {
  return {
    old: { element: t },
    new: { element: e }
  };
}
const Ye = (t) => t.map((e) => e.label);
function Zt(t, e, n) {
  let { doc: r } = e, l, c, s;
  function o(E) {
    E && (l = new N(E), c = new Et(l));
  }
  let i = [];
  async function u(E) {
    if (E === N.SelectorDOType) {
      n(10, i = await c.findDuplicateObjectTypes());
      return;
    }
    if (E === N.SelectorDAType) {
      n(10, i = await c.findDuplicateDataAttributeTypes());
      return;
    }
    if (E === N.SelectorLNodeType) {
      n(10, i = await c.findDuplicateLogicalNodeTypes());
      return;
    }
    if (E === N.SelectorEnumType) {
      n(10, i = await c.findDuplicateEnumTypes());
      return;
    }
    n(10, i = []);
  }
  let a = [];
  function d(E) {
    return E ? E.map((O) => O.map((G) => ({
      label: G.element.id,
      usages: G.usages.map(p)
    }))) : [];
  }
  function p(E) {
    const O = "~name not found~", G = E.element.parentElement;
    return G ? {
      name: G.getAttribute("id") ?? G.getAttribute("name") ?? O,
      type: G.tagName
    } : Ft;
  }
  let y = -1;
  function k(E) {
    n(0, y = E.detail.index);
  }
  const _ = [
    {
      id: N.SelectorLNodeType,
      label: "LNType"
    },
    {
      id: N.SelectorDOType,
      label: "DOType"
    },
    {
      id: N.SelectorDAType,
      label: "DAType"
    },
    {
      id: N.SelectorEnumType,
      label: "EnumType"
    }
  ];
  let v = _[0].id;
  function q(E) {
    const G = E.target.value;
    n(1, v = G);
  }
  let T = [];
  function Q(E, O) {
    if (!(O > -1)) {
      H();
      return;
    }
    if (!(E.length > 0)) {
      H();
      return;
    }
    const te = E[O];
    if (!((te == null ? void 0 : te.length) > 0)) {
      H();
      return;
    }
    const z = te[0], D = Array.from(z.element.element.children).map((oe) => oe.getAttribute("name") ?? "");
    n(4, T = D.filter(Boolean));
  }
  function H() {
    n(4, T = []);
  }
  function B(E) {
    const { selectedIndexes: O, selectedMergeTargetIndex: G } = E.detail, le = i[y], te = O.map((oe) => le[oe]), ne = le[G], Z = { action: { actions: te.map((oe) => oe.usages.map((re) => Wt(re, ne.element))).flat() } }, D = new CustomEvent("editor-action", { detail: Z, composed: !0, bubbles: !0 });
    s.dispatchEvent(D);
  }
  function J(E) {
    De[E ? "unshift" : "push"](() => {
      s = E, n(2, s);
    });
  }
  return t.$$set = (E) => {
    "doc" in E && n(9, r = E.doc);
  }, t.$$.update = () => {
    t.$$.dirty & /*doc*/
    512 && o(r), t.$$.dirty & /*selectedType*/
    2 && u(v), t.$$.dirty & /*duplicateGroups*/
    1024 && n(3, a = d(i)), t.$$.dirty & /*duplicateGroups, selectedGroupIndex*/
    1025 && Q(i, y);
  }, [
    y,
    v,
    s,
    a,
    T,
    k,
    _,
    q,
    B,
    r,
    i,
    J
  ];
}
class $t extends ee {
  constructor(e) {
    super(), x(this, e, Zt, Kt, V, { doc: 9 });
  }
}
const rt = "@oscd-plugins/dedupe", xt = "0.0.7";
function Ze(t) {
  let e = (
    /*doc*/
    t[0]
  ), n, r, l = $e(t);
  return {
    c() {
      l.c(), n = tt();
    },
    m(c, s) {
      l.m(c, s), A(c, n, s), r = !0;
    },
    p(c, s) {
      s & /*doc*/
      1 && V(e, e = /*doc*/
      c[0]) ? (pe(), C(l, 1, 1, U), ge(), l = $e(c), l.c(), S(l, 1), l.m(n.parentNode, n)) : l.p(c, s);
    },
    i(c) {
      r || (S(l), r = !0);
    },
    o(c) {
      C(l), r = !1;
    },
    d(c) {
      c && w(n), l.d(c);
    }
  };
}
function $e(t) {
  var r;
  let e, n;
  return e = new $t({
    props: { doc: (
      /*doc*/
      (r = t[0]) == null ? void 0 : r.documentElement
    ) }
  }), {
    c() {
      $(e.$$.fragment);
    },
    m(l, c) {
      W(e, l, c), n = !0;
    },
    p(l, c) {
      var o;
      const s = {};
      c & /*doc*/
      1 && (s.doc = /*doc*/
      (o = l[0]) == null ? void 0 : o.documentElement), e.$set(s);
    },
    i(l) {
      n || (S(e.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), n = !1;
    },
    d(l) {
      Y(e, l);
    }
  };
}
function en(t) {
  let e, n, r, l, c, s = (
    /*doc*/
    t[0] && Ze(t)
  );
  return {
    c() {
      s && s.c(), e = L(), n = g("input"), r = L(), l = g("input"), b(n, "type", "hidden"), b(n, "name", "package-name"), n.value = rt, b(l, "type", "hidden"), b(l, "name", "package-version"), l.value = xt;
    },
    m(o, i) {
      s && s.m(o, i), A(o, e, i), A(o, n, i), A(o, r, i), A(o, l, i), c = !0;
    },
    p(o, [i]) {
      /*doc*/
      o[0] ? s ? (s.p(o, i), i & /*doc*/
      1 && S(s, 1)) : (s = Ze(o), s.c(), S(s, 1), s.m(e.parentNode, e)) : s && (pe(), C(s, 1, 1, () => {
        s = null;
      }), ge());
    },
    i(o) {
      c || (S(s), c = !0);
    },
    o(o) {
      C(s), c = !1;
    },
    d(o) {
      s && s.d(o), o && w(e), o && w(n), o && w(r), o && w(l);
    }
  };
}
function tn(t, e, n) {
  let { doc: r } = e;
  return t.$$set = (l) => {
    "doc" in l && n(0, r = l.doc);
  }, [r];
}
class nn extends ee {
  constructor(e) {
    super(), x(this, e, tn, en, V, { doc: 0 });
  }
}
class rn extends HTMLElement {
  constructor() {
    super(...arguments);
    Ee(this, "plugin");
    Ee(this, "_doc");
  }
  connectedCallback() {
    this.attachShadow({ mode: "open" }), this.plugin = new nn({
      target: this.shadowRoot,
      props: {
        doc: this._doc
      }
    });
    const n = document.createElement("style");
    n.innerHTML = globalThis.pluginStyle[rt], this.shadowRoot.appendChild(n);
  }
  set doc(n) {
    this._doc = n, this.plugin && this.plugin.$set({ doc: n });
  }
}
export {
  rn as default
};
